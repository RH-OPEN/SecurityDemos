== Lab 4: Red Hat AdvancedClusterSecurity を使用したアプリケーションへの自動化セキュリティの実装とDevSecOpsの構築

=== ラボの目的

このラボの目標は、さまざまなセキュリティツールの組み合わせをオーケストレーションする、安全なソフトウェアファクトリを構築する方法を学ぶことです。DevSecOps の出現により、セキュリティは前面と中心に置かれ、人、プロセス、および、技術の面で対処されるようになりました。セキュリティツールはビルドプロセスに統合されており、CI/CDパイプラインに組み込まれたセキュリティゲートでセキュリティ要件が満たされない場合、ビルドを簡単に中断することができます。

=== 序章

DevOpsと継続的インテグレーション／継続的デリバリー（CI/CD）の利点は、長年にわたって大きな成果とともに実証されてきました。組織は常に、より少ない人数でより多くのことを行うことを求めてきました。セキュリティは多くの場合、ソフトウェア提供プロセスの末端のアドオンとして扱われ、ソフトウェアデリバリの遅延につながることも少なくありませんでした。業界は、これを変えなければならないことを認識しました。組織は、契約上および規制上の義務や社内のセキュリティ標準を引き続き満たす必要がありますが、機会を生かすためにソフトウェアデリバリを加速させる必要があります。組織がこれらの標準を満たし、DevOpsのスピードでデリバリーできるようにするために、セキュリティは、無関係になるか、最新のソフトウェアデリバリプラクティスに適合するかの選択に迫られています。セキュリティはソフトウェアを迅速に提供するために不可欠であり、ソフトウェア品質の指標となっているため、"DevOps" に "Sec" を含めることが推奨されています。DevSecOpsの登場により、Shift Leftはソフトウェアデリバリプロセスの早い段階で不具合を発見し、防止することを目的としたプラクティスとなりました。セキュリティツールは、ビルドプロセスに直接統合されます。その結果、CI/CDプロセスをより速く進め、デリバリーまでの期間を短縮しながら、各リリースの品質を継続的に向上させることができるのです。 +
この実習では、典型的な CI/CD アプリケーションパイプラインに自動化されたセキュリティコンプライアンス制御を実装するために使用される技術のいくつかに焦点を当てます。 +
DevSecOps パイプラインをサポートするために、多くのツールがインストールされ、事前に設定されています。これらのツールのほとんどは、Red Hat OpenShift クラスター内でコンテナ化されて実行されています。以下は、私たちのラボでステップスルーするパイプラインです:

image:images/lab4-devsecops01.png[800,800]

DevSecOpsのCI/CDパイプラインでは、次のような技術を使用します:

- https://tekton.dev[Tekton] をベースとした https://www.openshift.com/learn/topics/ci-cd[OpenShift Pipelines] 
- https://argoproj.github.io/[ArgoCD] をベースとした https://www.openshift.com/blog/announcing-openshift-gitops[OpenShift GitOps]
- https://www.redhat.com/en/resources/advanced-cluster-security-for-kubernetes-datasheet[Red Hat Advanced Cluster Security for Kubernetes]
- https://docs.openshift.com/container-platform/latest/registry/architecture-component-imageregistry.html[OpenShift Container Registry]
- https://www.sonarqube.org/[SonarQube]
- https://www.sonatype.com/products/repository-oss?topnav=true[Nexus]
- https://junit.org/junit5/[JUnit]
- https://gogs.io/[Gogs]
- https://tekton.dev/docs/triggers/[Git Webhook]
- https://gatling.io/[Gatling]
- https://www.zaproxy.org/[Zap Proxy]

[#beforeyoustart]
=== 始める前に

講師からの情報は、このラボで使用されます:

- RHEL 8 VM (bastion)へのユーザー名とパスワードによるアクセス
- OpenShift コンソール URL
- OpenShift API サーバ
- OpenShift 管理者のユーザ名とパスワード

以下は登録情報の一例です:

image:images/lab4-devsecops02.png[800,800]

=== ユーザー要件

- 最新のブラウザー: ChromeとFirefoxを推奨
- コマンドラインと``oc``ツールは、ラボに付属しているBastion VMに含まれています。

* 以下のコマンドのように、割り当てられた VM に SSH 接続します:
+
[source]
----
 ssh lab-user@bastion.GUID.sandbox####.opentlc.com
----
+
* oc コマンドラインユーティリティが使用可能かどうかを確認するには、ターミナルを開いて以下のコマンドを実行します:
+
[source]
----
 oc version
----
+
* コマンドラインからコンソールの URL を取得する場合:
+
[source]
----
oc login -u admin api.cluster-{GUID}.{GUID}.sandbox###.opentlc.com:6443
----
+
``oc login`` のAPIサーバー情報は、xref:beforeyoustart[始める前に] に記載されています。
+
* また、ラップトップでocクライアントをセットアップする場合は、以下の手順を実行します:
+
** OpenShift コンソールにログインしてください。OpenShiftコンソールの管理者ユーザーパスワード情報は、講師から提供されます。
右上のクエスチョンマークを選択し、“Command Line Tools” を選択します。
+
image:images/lab4-devsecops03.png[200,200]
+
** 選択したオペレーティングシステム用のocコマンドラインツールをダウンロードします。
** ocコマンドラインツールをシステムの実行ファイルの場所に移動しておくと、演習中に簡単にアクセスできるようになります。
+
例えばMacbookの場合、次のコマンドを実行します。
+
|===
|mv <insert-download-path> /usr/local/bin /usr/local/bin/
|===
+
* インターネット接続可能なラボ環境
* GitHub へのインターネットアクセス

=== Lab 4.1 継続的インテグレーション

この最初のモジュールは、OpenShift Pipeline を実行し、サンプルの安全なパイプラインのステップを探ってみましょう。 +
このラボでは、Tekton パイプラインの開始方法と、開発ライフサイクル内でセキュリティと gitops ツールを統合するためのタスクの使用方法を学習します。

. パイプラインを開始するには、3つの方法があります:
** Option 1: Developer UIを使用して開始する
.. ブラウザで OpenShift Console の URL を参照する。
.. 提供されたadminユーザの認証情報を使用してコンソールにログインする。
.. まだ開発者パースペクティブにいない場合は、左上の開発者コンソールに切り替えるためにDeveloperを選択します。
+
image:images/lab4-devsecops04.png[200,200]
+
.. ocp-workshop プロジェクトに移動します。
+
image:images/lab4-devsecops05.png[200,200]
+
.. 左メニューの ``Pipelines`` をクリックすると、すべてのパイプラインが表示されます。
+
image:images/lab4-devsecops06.png[400,700]
+
.. " petclinic-build-dev "パイプラインをクリックします。
+
image:images/lab4-devsecops07.png[600,800]
+
.. 右上の “Actions” をクリック → “start” を選択します。
.. "Workspaces"でPVCを選択し、パイプラインが実行時に使用する共有ストレージのパスとしてPVC petclinic-build-workspaceを選択します。
.. "maven-settings" で「Config Map」を選択し、"maven-settings" をConfig Mapとして選択します。
+
image:images/lab4-devsecops08.png[200,700]
+
.. start をクリックします。
+
** Option 2: コマンドラインからパイプラインを起動する。
コマンドラインはテスト中にパイプラインを開始するのに便利な方法で、PRやgitへのpushをシミュレートしてパイプラインを起動させる方法です。CLIでパイプラインを開始するのが好きなユーザー向けです。
+
.. 実行:
+
[source]

|===
|oc create -f https://raw.githubusercontent.com/RedHatDemos/SecurityDemos/master/2021Labs/OpenShiftSecurity/documentation/labs-artifacts/pipeline-build-dev-run.yaml -n ocp-workshop

|===
+
** Option 3: 新しいコードがgit repoにpushされると、パイプラインを開始するトリガーにもなります。このラボでは、git repo は Gogs です。以下の手順は、「Gogs」git repo経由でコードをプッシュするためのものです。
このオプションは、開発者の観点からすると最もポピュラーなものかもしれません。PR や git リポジトリへのプッシュからパイプラインが始まり、webhook が自動的にパイプラインを開始します。
+
.. 開発コンソールから、左のナビメニューにある `Search` をクリックします。
.. 'route'と入力し、リストの中から``Route``をクリックします。
+
image:images/lab4-devsecops09.png[400,400]
+
.. `Gogs` ルートをクリックすると、gogs の URL が表示されます:
+
image:images/lab4-devsecops10.png[400,600]
+
.. ``サインイン``をクリックし、__gogsadmin__の認証情報でログインします。
+
image:images/lab4-devsecops11.png[500,400]
+
|===
|User: gogsadmin
|Password: openshift
|===
+
.. gogsadminアカウント内のspring-petclinicリポジトリを選択します:
+
image:images/lab4-devsecops12.png[400,700]
+
.. README.mdをクリックし、``Edit this file``をクリックし、変更を加えてください:
+
image:images/lab4-devsecops13.png[400,700]
+
.. 導入した変更をREADME.mdにコミットします:
+
image:images/lab4-devsecops14.png[400,700]
+
[注意] これはあくまでデモのためのものです。通常、master への push は推奨されず、代わりに他のブランチ (例えば develop) からの Pull Request / Merge Request を使用します。
+
.. パイプラインは自動的にトリガーされます。このラボのステップ 6 にスキップして、Pipeline Runs コンソールを確認してください。
+
. 提供されたOpenShiftコンソールのURLを使って、ブラウザを開きます。
. 提供されたクレデンシャルを使用してコンソールにログインします。
. ``Developer``をクリックすると、開発者用コンソールに切り替わります。
+
image:images/lab4-devsecops04.png[200,200]
+
. ``ocp-workshop``プロジェクトが選択されていることを確認してください。
+
image:images/lab4-devsecops15.png[300,300]
+
. 左メニューの `Pipelines` をクリックすると、すべてのパイプラインが表示されます。
+
image:images/lab4-devsecops16.png[400,700]
+
. パイプラインの `petclinic-build-dev` をクリックし、`Pipeline Runs` タブをクリックします。
+
image:images/lab4-devsecops17.png[400,700]
+
. パイプラインの実行をクリックします。
+
起動すると下図のようなPipeline Runが表示されますので、ご覧ください。
+
image:images/lab4-devsecops18.png[500,700]
+
パイプライン実行のステップ「image-check」で失敗します。これは、イメージに含まれる重要な深刻度の脆弱性がパイプラインゲートポリシーに引っかかり、デプロイが停止するためです。
+
image:images/lab4-devsecops20.png[500,700]
+
パイプラインを正常に完了させるためには、この脆弱性を修正する必要があります。次のモジュールでそれを行います。以下は、正常に実行された場合の様子です。
+
image:images/lab4-devsecops19.png[500,700]
+
次のモジュール、Lab 4.2では、何が起こったのか、それを安全に解決する方法について説明します。
+
[注意] 手動でパイプラインを実行するトリガーに加え、Gogs gitサーバー上のspring-petclinic gitリポジトリにpushするたびに、パイプラインが実行されます。
. パイプラインを探索しようパイプラインが開始されると、各詳細なステップをクリックして、各ステップのログを探索することができます。次の数ステップで探索の一部を指示します。
.. *Source Clone* - アプリのソースコードは、このラボにインストールされているGit（Gogs）サーバーから引き出されています。
+
[注意] ファイルは、パイプラインにあらかじめ設定されたワークスペースを介して、パイプラインのステップ間で持続されます。
+
image:images/lab4-devsecops24.png[400,700]
+
... git repo の URL をコピーします。ブラウザのタブを開いて、コードを探索する
... URLは以下のようにGogsのgit repoに移動します。
+
image:images/lab4-devsecops25.png[600,700]
+
... ``gogsadmin``をクリックすると、このラボのための2つのリポジトリがあります。
+
gogsadminユーザの認証情報は以下の通りです:
+
|===
|User: gogsadmin
|Pass: openshift
|===
+
.. *Dependency Report* は、ソースコードからアプリの依存関係のレポートを作成し、レポートサーバーリポジトリにアップロードするパイプラインのステップです。
+
image:images/lab4-devsecops26.png[300,700]
+
reportを見てみましょう!
+
... 開発コンソールから、左のナビメニューにある `Search` をクリックします。
... Resourcesをクリックし、``route``と入力、リストから``Route``をクリックします。
+
image:images/lab4-devsecops09.png[400,400]
+
... reports-repo のリンクをクリック。
+
image:images/lab4-devsecops27.png[300,700]
+
... このページの `petclinic-build` リンクをクリックします。
+
image:images/lab4-devsecops28.png[300,500]
+
... 引き続き、spring-petclinic → target → site をクリックします。
... そのページから `Dependencies` をクリックします。そのページから、下にスクロールすることで詳細を調べることができます。
+
image:images/lab4-devsecops29.png[300,700]
+
.. *Unit tests* タスクは、依存性レポートと並行して実行されます。
+
image:images/lab4-devsecops30.png[300,700]
+
. *Release-app* はアプリケーションをJARとしてパッケージ化し、Sonatype Nexusのスナップショットリポジトリにリリースする場所です。
+
image:images/lab4-devsecops31.png[300,700]
+
. *Build-image* ステップは、DEV環境でS2Iを使ってコンテナイメージをビルドし、OpenShiftの内部レジストリにプッシュし、spring-petclinic:[branch]-[commit-sha] および spring-petclinic:latest でタグ付けします。
+
image:images/lab4-devsecops32.png[300,700]

=== Lab 4.2 Advanced Cluster Securityを利用したDevSecOpsのステップ

Red Hat Advanced Cluster Security (ACS) for Kubernetes は、ビルトインのセキュリティポリシーにより、単一のコンソールからクラスタとアプリケーションを制御します。 +
第一世代のコンテナセキュリティプラットフォームは、コンテナに焦点を当てます。ACSはKubernetesにフォーカスしており、Kubeの宣言型データとビルトイン制御を活用したKubernetesネイティブアーキテクチャにより、リッチなコンテキスト、ネイティブな実施、継続的なハードニングを実現し、DevOpsとセキュリティチームのセキュリティ運用を支援します。さらに、ACS focuses on Kubernetesは、DevOpsおよびセキュリティチームがセキュリティを運用できるよう支援し、クラウドネイティブなアプリケーションスタックを保護するプロセスを簡素化します。

このラボでは、ACS が CI/CD プロセスにどのように統合されるかを学びます。ACSはプロセスを簡素化するだけでなく、組織内のセキュリティチームに可視性を提供します。
 https://docs.openshift.com/acs/cli/getting-started-cli.html[roxctl] ACS API を使って、いくつかの追加のセキュリティステップを DevSecOps のパイプラインに統合しました:

. *image scan* のステップでは、ACSスキャナを使用して、最後のステップで生成され、プッシュされたイメージをスキャンします。
+
image:images/lab4-devsecops33.png[300,700]
+
ログにある以下のエラーは、`pretty` フォーマットが非推奨であることが原因です。
+
|===
|ERROR:	invalid output format "pretty" used. You can only specify json or csv
|===
+
フォーマットを変更するには、以下の手順で行います。

.. 左のメニューから `Pipelines` をクリックします。
.. `petclinic-build-dev` パイプラインをクリックします。
.. `Actions` -> ``Edit Pipeline``をクリックします。
.. `image-scan` タスクをクリックし、`pretty` の代わりに `csv` を使用します。
+
image:images/lab4.2-image-scan.png[500,700]
+
.. ``Save``をクリックします。
.. オプションで `Actions` -> rerun を選択すると、イメージスキャンの実際の出力が表示されます。
+
image:images/lab4.2-image-scan-withlogs.png[500,700]
+
このステップのログには、ACSのイメージスキャンへの直接のリンクがあります。
+
[注意] もし、そのリンク先にセキュリティ証明書の警告が表示されても無視してください。 +
コピーして別のタブに貼り付けると、スキャンしたイメージの詳細な情報を得ることができます。以下の情報を入力してください:
+
|===
|User: admin
|Pass: stackrox
|===
+
URLは、Vulnerability Managementに移動します。このImageに含まれる脆弱性(CVE)の概要を説明します。
+
image:images/lab4-devsecops35.png[500,700]
+
.. Deployment タブで、
ACSツールはこのイメージがデプロイされているかどうかを認識します。最初のパイプラインはすべてのゲートを通過しなかったので、最初はデプロイメントが表示されないでしょう。

.. Component タブは、
このイメージ内のすべてのコンポーネントのビューです。コンポーネントのアップグレードで修正可能な CVE の数、コンポーネントの CVE に関連する CVSS スコアのトップ、各コンポーネントを含む他のデプロイメントなどの関連情報が一覧表示されます。
+
image:images/lab4-devsecops34.png[500,700]
+
例えば、tomcat 9.0.31 コンポーネントをクリックすると、下図のようにコンポーネントの詳細が表示されます。このページには、リスクの優先順位、CVE の情報、コンポーネントの場所、CVE を修正するためにアップグレードするコンポーネントのバージョンが表示されます。
+
image:images/lab4.2-tomcat-cve.png[500,700]
+
.. 右上の “X” をクリックすると戻ることができます
.. CVEsタブは、Imageのすべての脆弱性を表示します。
+
image:images/lab4-devsecops36.png[500,700]
+
.. `Overview` タブに戻り、`Image findings` セクションにスクロールダウンすると、修正可能な CVE が表示されます。これらは、ACS が修正可能であることを認識している CVE です。
+
image:images/lab4-devsecops37.png[300,700]
+
.. ``Image Findings``セクションの上にある ``Dockerfile`` セクションを '>' をクリックして展開すると、ACS CVEデータベースにより、各ステップごとに詳細なイメージコンポーネントと関連するCVEが表示されます。
+
image:images/lab4-devsecops38.png[400,700]
+
パイプラインの復習を続ける前に、ACSの探索を自由に行ってください。セキュリティチェックとツールの機能を理解することは、このラボの重要な部分であり、安全なソフトウェア配信パイプラインの知識を高めるのに役立ちます。
+
ここで、OpenShift Developerのコンソールに戻ります。
. パイプラインの *Image Check* ステップ
+
[注意] ACSで定義されている様々なセキュリティポリシーのビルド時の違反
+
image:images/lab4-devsecops39.png[400,700]
+
image:images/lab4-devsecops40.png[400,700]
+
このステップでは、このイメージを使用するすべてのデプロイメントについて、ACS で定義されたセキュリティ ポリシーのビルド時およびデプロイ時の違反をチェックします。セキュリティポリシー違反のため、ACSでセキュリティポリシーの実施を設定したため、このパイプラインはこのタスクで失敗します。
脆弱性の高いコンテナ型アプリケーションを展開しないためには、イメージのスキャンが重要です。

. *Deploy-check* は、ログにポリシーの違反が表示されます。ログには違反が表示されていますが、この例ではデプロイの強制がオンになっていないため、このタスクで失敗することはありませんでした。この後のラボで、ポリシーの詳細を確認します。
+
image:images/lab4-devsecops41.png[400,700]
+
[注意] この3つのステップ（*deploy-check, image-check, image-scan*）は、DevSecOpsパイプラインの時間短縮のために並行して実行されます。
+
. もし *image-check* が失敗したら、パイプラインの実行に移動して `image-check` をクリックします。ログの一番下に `Error: failed policies found: 1 policy violated that are failing the check.` と表示されます。このエラーの原因は、違反が発生した場合に ACS がビルドやデプロイからポリシーを強制するためです。パイプラインでは、Tektonタスクのroxctlを介してACSを統合しています。
+
Imageがポリシーに違反した場合、コードを修正し、チェックに合格するまでパイプラインを実行することがベストプラクティスです。ログには違反の一覧と対処法が報告されています。開発者は `image-check` タスクのログから情報を取得し、それに応じて変更を加えることができます。修正がGitにチェックインされると、パイプラインが起動されます。今回、xref:fiximage[Imageを修正するためのボーナスエクササイズ]を用意しました。もし、パイプライン上で他のタスクのテストを続けたい場合は、ポリシーに例外を追加して、spring-petclinicを除外することができます。
ポリシーに例外を追加することは、開発者がコードを修正する必要があり、CIプロセスがテストを継続する必要がある場合に有効である。
+
[注意] 違反が通るようにコードを修正することが推奨されるアプローチになることに注意してください。
+
spring-petclinicビルドのポリシーをバイパスする例外を追加したい場合を想定しています。
+
.. *image-check* タスクのログを調べると、以下のような失敗の原因となるメッセージが見つかります:
+
|===
|✗ Image image-registry.openshift-image-registry.svc:5000/ocp-workshop/spring-petclinic@sha256:ece54d2923654c36f4e97bc0410f5c027871c5b7483e977cfc6c2bd56fef625d and '*ERROR: Policy "Fixable Severity at least Important"*'
|===
+
.. `ワッフルアイコン` image:images/lab4-devsecops42.png[20,20] をクリックしてコンソールリンクを表示 → 以下のように `Red Hat Advanced Cluster Security For Kubernetes` を選択します。
+
image:images/lab4-devsecops43.png[700,300]
+
.. ACSコンソールにログインするよう促されます → `Advanced` をクリック → `Proceed to central-stackrox.apps.cluster...` リンクをクリックして進みます。
.. 以下の情報を入力してください:
+
|===
|User: admin
|Pass: stackrox
|===
+
.. ログインをクリックし、以下のようにパイプラインを再実行します。
+
image:images/lab4-devsecops44.png[300,700]
+
.. 左上の image:images/lab4-devsecops45.png[20,20] をクリック → Platform Configuration をクリック → Policies を選択します。
+
image:images/lab4-devsecops46.png[100,200]
+
.. Policies の下にある検索フィールドに、ポリシー名 *Fixable Severity at least Important* を入力し、Enterキーを押します。結果、ポリシーが表示されます。
+
image:images/lab4-devsecops47.png[300,700]
+
[注意] UI上で https://issues.redhat.com/browse/ROX-9938[bug] に遭遇したため、ACS UI経由でポリシーにビルドイメージの例外を追加することができなくなります。ここでの手順は、回避策です。ACS v3.70では、SHAなしでUI経由でビルドイメージを追加できるようになります。
+
* `Fixable Severity at least Important` をクリックすると、ポリシーの詳細ページが表示されます。ポリシーページでは、`Actions` でポリシーの編集、クローン、エクスポート、無効化ができます。`Actions` の中にある ``Clone policy`` をクリックします。開発者はガイダンスの情報を使って、イメージを修正することができます。ライフサイクルステージの情報は、ポリシーの強制が行われる場所です。有効なポリシーに違反しているため、パイプラインのビルドとデプロイのステージを通過することはできません。
+
image:images/lab4-devsecops48.png[300,700]
+
* クローンポリシー名を `Fixable Severity at least Important - with Exception` と入力します。
+
image:images/lab4.2-5-clone-policy-name.png[300,700]
+
* `Next` をクリックします。
* Policy behaviorで `Next` をクリックします。
* Imageを除外するために、Policy criteria の `Next` をクリックし、Policy scope セクションの UI を表示します。
* Exclude imagesセクションで、`Excluded Images (Build Lifecycle only)` リストのオプションをフィルタリングするために以下をタイプします:
+
|===
|image-registry.openshift-image-registry.svc:5000/ocp-workshop/spring-petclinic
|===
+
* spring-petclinic のImageを1つ選択してください。
+
image:images/lab4.2-5-exclude-image.png[300,700]
+
* `Next` をクリックします。
* `Save` をクリックする前に、ポリシーをご確認ください。
* ここで、新しく作成した Image例外ポリシー `Fixable Severity at least Important - with Exception` を更新する必要があります。
* 左メニューの `Policies` をクリックします。
* `Fixable Severity at least Important - with Exception` のポリシーを検索してください。
+
image:images/lab4.2-5-exceptionPolicy.png[300,700]
+
* ポリシーをクリックします。
* Actions をクリック -> Export policy to JSON をクリック
+
image:images/lab4.2-5-exportPolicy.png[300,700]
+
* 選択したローカルファイルシステムとして保存します。
* JSONファイルをお好みのエディタで開きます。
+
image:images/lab4.2-5-editPolicy.png[300,700]
+
* Image名から `@sha256:..` 以降のSHA部分を削除します。
+
image:images/lab4.2-5-editpolicy2.png[300,700]
+
* ファイルを保存します。
* ACS コンソールに戻り、 `Fixable Severity at least Important - with Exception` ポリシー詳細ページで、 `Actions` -> `Delete policy` を選択します。
* 左メニューの `Policies` をクリックします。
* 右上の `Import policy` をクリックします。
* `Upload` をクリックし、編集したJSONファイルを選択します。
+
image:images/lab4.2-5-importPolicy.png[200,500]
+
* `Begin import` をクリックします。
* ポリシー ``Fixable Severity`` を選択してください。
+
image:images/lab4.2-5-filterPolicy.png[300,700]
+
* `Fixable Severity at least Important` の末尾の3点アイコンをクリック -> `Disable policy` を選択します。
+
image:images/lab4.2-5-disablePolicy.png[300,700]
+
.. これで、``Fixable Severity``のポリシーは以下のようになります。
+
image:images/lab4.2-5-2Policy.png[300,700]
+
.. OpenShift developer console に戻り、ナビの “ocp-workshop” プロジェクトの下にあるパイプラインをクリックします。
+
image:images/lab4-devsecops52.png[300,700]
+
.. パイプラインを再実行します。
+
image:images/lab4-devsecops53.png[300,700]
+
.. Pipeline Runsタブをクリックし、開始したPipeline Runをクリックします。
+
image:images/lab4-devsecops54.png[300,700]
+
image:images/lab4-devsecops55.png[300,700]
+
.. xref:fiximage[bonus lab] でImageを修正し終えたら、ポリシーに戻って、ポリシーの例外を削除します。
.. Kubernetes kustomization ファイルは、*update deployment step* で、dev用のオーバーレイにある最新のイメージ [commit-sha] で更新されます。これにより、私たちのアプリケーションは、このパイプラインで特定のビルドされたイメージを使用してデプロイされることが保証されます。
+
image:images/lab4-devsecops56.png[300,700]


=== Lab 4.3 GitOpsを使った継続的デリバリー

GitOpsは、クラウドネイティブなアプリケーションの継続的なデプロイメントを実装するための宣言的な方法です。GitOpsを使用して、マルチクラスタKubernetes環境にわたるOpenShift Container Platformクラスタとアプリケーションを管理するための反復可能なプロセスを作成することができます。GitOpsは、複雑なデプロイメントを高速に処理し自動化することで、デプロイとリリースサイクルの時間を短縮します。 +
GitOps のワークフローは、アプリケーションを開発、テスト、ステージング、そして本番へとプッシュします。GitOps は新しいアプリケーションをデプロイするか既存のアプリケーションを更新するので、私たちはリポジトリを更新するだけでよく、他のすべては GitOps が自動化します。

Argo CD は Git リポジトリに保存された設定を継続的に監視し、DEV および STAGE 環境にアプリケーションをデプロイする際に、Kustomize を使用して環境固有の設定をオーバーレイします。

image:images/lab4-devsecops57.png[300,700]

. ArgoCD アプリケーションは、Gogs の git リポジトリにあるマニフェストを同期し、定義されたネームスペースに自動的に変更を適用します:
.. 上部のワッフルアイコンをクリックしてコンソールリンクに移動し、"Cluster Argo CD "を選択します。
+
image:images/lab4-devsecops43.png[300,300]
+
.. リンクは Argo CD のログインにリダイレクトされます。初めてArgo CDにログインする場合は、``LOG IN VIA OPENSHIFT`` のリンクをクリックしてください。
.. "admin" ユーザーとしてログインするためには、まず、以下のコマンドを実行して、そのパスワードを取得してください。
+
[source]
----
oc get secret/openshift-gitops-cluster -n openshift-gitops -o jsonpath='{.data.admin\.password}' | base64 -d
----
+
.. ログインすると、以下のように Argo CD コンソールにアプリケーションがリストアップされます。
+
image:images/lab4-devsecops58.png[500,600]
+
.. ``dev-spring-petclinic`` をクリックすると、アプリケーションにアクセスできます。
. ArgoCD は、アプリケーションの branch/repo に定義されているすべてのマニフェストをデプロイします。アプリケーションには "Synced" と表示されています。
+
image:images/lab4-devsecops59.png[300,700]
+
.. image:images/lab4-devsecops101.png[100,90] をクリックすると 'dev-spring-petclinic' アプリケーションの詳細が表示されます。
+
image:images/lab4-devsecops102.png[900,700]
+
.. 上記の詳細には、アプリケーションがデプロイされているネームスペースが表示されます。OpenShift Dev コンソールに戻り、左側のナビゲーションメニューから devsecops-dev project の下にある ``Topology`` をクリックします。矢印をクリックすると、アプリケーションの URL にアクセスできます。
+
image:images/lab4-devsecops60.png[300,500]
+
* アプリケーションは以下のように表示されます。
+
image:images/lab4-devsecops61.png[500,500]
+
.. Argo CD コンソールに戻ります。左上の ``Applications`` をクリックします。
+
[注意]  `stage-spring-petclinic` の namespace は devsecops-qa に設定されています。
+
image:images/lab4-devsecops62.png[300,300]
+
.. `stage-spring-petclinic` をクリック
+
image:images/lab4-devsecops63.png[300,700]
+
.. トップメニューの image:images/lab4-devsecops64.png[40,50] をクリックして、アプリケーションを devsecops-qa にデプロイし、以下のように “Synced” されるまで待ちます。
+
image:images/lab4-devsecops65.png[300,700]
+
.. OpenShift Dev コンソールに戻り、左のナビゲーションメニューから devsecops-qa project の下にある ``Topology`` をクリックします。矢印アイコンをクリックして、アプリケーションの URL にアクセスします。
+
image:images/lab4-devsecops66.png[300,300]
+
.. 以下のように、devsecops-qa プロジェクトにアプリケーションがデプロイされました。
+
image:images/lab4-devsecops67.png[300,500]

=== Lab 4.4 PostCI - ダイナミックアプリケーションセキュリティとテスト (DAST)

*動的アプリケーションセキュリティテスト (DAST)* は、アプリケーションの実行状態において、セキュリティ上の脆弱性を示唆する状態を検出するために設計されています。DASTは、運用中のアプリケーションの脆弱性を特定する上で重要な役割を担っています。DASTの侵入テストを実行することで、攻撃者よりも先にそれらの脆弱性を発見することができます。
このラボでは、例としてZAPを使用してアプリケーションセキュリティテストを実施します。アプリケーションがDevからQAに昇格した後、パフォーマンステストとペネトレーションテストが並行して開始されます。

. Openshift Pipelines の CI は、ArgoCD アプリが完全に同期され (*Wait Application step*) 、私たちのアプリとすべてのリソースがデプロイされるまで待ちます。
.. 成功した実行済のパイプラインに移動し、ステップ *wait-application* に移動します。
+
image:images/lab4-devsecops68.png[300,700]
+
.. ステップをクリックすると、以下のようなログが表示されます。
+
このステップでは、ArgoCD インスタンスへの認証を行い、Git リポジトリ（gogs）から OCP クラスタ内のターゲットプロジェクトに 'dev-spring-petclinic' アプリケーションの同期処理を開始します。
+
image:images/lab4-devsecops69.png[300,700]
+
. パイプラインをクリックして、*perf-test-clone* のステップを実行します。
+
パフォーマンステストは、以下のようにパイプラインのワークスペースにクローン（*Performance Tests Clone*）されます。
+
image:images/lab4-devsecops70.png[300,700]
+
. ステップ *pentesting-test* をクリックします。
+
Web スキャナ https://www.zaproxy.org/[OWASP Zap Proxy] を用いて、ベースラインを用いたペンテストを実行し（*ペンテストテスト*）、可能性のある脆弱性を確認します。Zap Proxyのレポートがレポートサーバーリポジトリにアップロードされます。
結果はログの最下行からご覧ください。
+
image:images/lab4-devsecops72.png[300,700]
+
. パフォーマンスレポートがレポートサーバーリポジトリにアップロードされます。
.. 左側のナビゲーションの `Route` をクリックし、`reports-repo` のルートロケーションをクリックします。
+
image:images/lab4-devsecops73.png[300,700]
+
.. リンクは、PipelineRun の名前に対応した名前を持っています。
.. PipelineRun と同じ名称のリンクをクリックしてください。同様のリンクは以下の通りです。
+
image:images/lab4-devsecops75.png[300,400]
+
.. ルートの場所の下にある petclinic-build-dev-XXXX.html にアクセスしてください。
+
image:images/lab4-devsecops76.png[300,700]
+
. 並行して、負荷テスト https://gatling.io/[Gatling] を使ってパフォーマンステストが実行されます。パイプラインの実行から "performance-test" をクリックします。
+
image:images/lab4-devsecops77.png[300,700]
+
.. レポートの場所を見るにはスクロールしてください
+
image:images/lab4-devsecops78.png[300,700]
+
.. レポートのレポの場所に戻ります:
+
image:images/lab4-devsecops79.png[300,400]
+
.. Pipeline Runの名前に一致するリンクをクリックし、`performance-test` タスクログにも表示されているパフォーマンステスト "addvisitsimulation" に対応するリンクを選択します。
+
image:images/lab4-devsecops80.png[200,400]
+
.. 下の画像のようなパフォーマンステストのページをご覧ください。
+
image:images/lab4-devsecops81.png[400,700]


=== Lab 4.5 セキュリティポリシーとCI違反について

このデモでは、パイプラインに適用されるセキュリティポリシーの制御、イメージのスキャン、アプリケーションのデプロイに使用されるさまざまなデプロイメントテンプレートの分析が可能です。 +
ACSで異なるセキュリティポリシーを適用し、このポリシー違反がDevSecOpsパイプラインの各ステップ（ステップ “image-check”, “image-scan”, “deploy-check”) に現れるとCIパイプラインを失敗させることが可能です。 

* `waffle icon` をクリックし、 `Red Hat Advanced Cluster Security for Kubernetes` を選択します。
+
image:images/lab4-devsecops43.png[300,300]
+
* ACS コンソールに admin/stackrox というクレデンシャルでログインしてください。
+
image:images/lab4-devsecops82.png[300,700]
+
* Platform Configuration → Policies をクリックします。
+
image:images/lab4-devsecops83.png[200,200]
+
セキュリティポリシーは、BUILDレベル（イメージのビルド/プッシュ時）、またはDEPLOYMENTレベル（アプリケーションのデプロイを阻止する）で定義することができます。
* ``Red Hat Package Manager in Image`` をクリックします。
+
image:images/lab4-devsecops84.png[300,700]
+
例えば、このセキュリティポリシーは、アプリケーションイメージにRHパッケージマネージャ（dnf、yum）が含まれているかどうかをチェックし、ビルドされたイメージにRHパッケージマネージャが含まれていることを検出するとパイプラインをFAILにします。
* ポリシーの内容は変更することができます。また、ライフサイクルステージは、ポリシーとその他のプロパティで定義されます。ポリシーオプションを有効にすると、ユーザーがCIを制御して失敗または合格することができます。
+
image:images/lab4-devsecops85.png[300,700]
+
* `Actions` -> `Edit policy` をクリックします。
* `Policy details` の `Next` をクリックします。 
* レスポンスの方法は `Inform and enforce` を選択します。
* ビルド時 `Enforce on Build` を選択します。
+
image:images/lab4-devsecops87.png[300,700]
+
* `Next`, `Next`, `Next` そして `Save` と順番にクリックします。
このステップでは、ユーザがパイプラインを完全に制御できるようにします。定義されたセキュリティポリシーを超えるImageは、イメージレジストリにプッシュされたり、クラスタにデプロイされることはありません。


[#fiximage]
=== Lab 4.2のボーナスラボ：Image を修正する

``bad image``のビルドに強制合格するImageへの移行を示せる、完全なデモのために、Image ビルドのTektonタスクを更新し、Imageを修正することができます。
この例では、ACS で ``Red Hat Package Manager in Image`` ポリシーの実施を有効にしています。これは、ベースイメージに yum と rpm の両方のパッケージマネージャーが存在するため、イメージチェックでパイプラインが失敗することになります。

. 前のセクションで行ったように、*Fixable Severity at least important* ポリシーで違反を回避する例外を追加します。
. *Red Hat Package Manager in Image* ポリシーの実施を有効にします:
.. `Platform Configuration` → `Policies` に移動します。
.. `Red Hat Package Manager in Image` のポリシーを検索します。
+
image:images/lab4-devsecops88.png[300,700]
+
.. `Red Hat Package Manager in Image` policy をくりっくします。
.. `Actions` -> `Edit policy` をクリックします。
.. `Next` をクリックします。
.. `Inform and enforce` を選択します。
.. `Configure enforcement behavior`の Build で `Enforce on Build` を選択したことを確認します。
+
image:images/lab4-devsecops87.png[300,600]
+
.. `Next` をクリックし `Review policy` ページに移動します。
.. `Save` をクリックします(変更がある場合)。
.. OpenShift Dev UI を開き、左側の Pipelines をクリック → `petclinic-build-dev` pipeline をクリック → 右上の Actions をクリック → `Start last run` を選択します。
+
image:images/lab4-devsecops91.png[300,700]
+
.. イメージに"rpm"と"yum"パッケージマネージャーがインストールされているため、**image-check**ステップで失敗することを確認し、確認します。**image-check**ステップからの提案に注目してください:
+
image:images/lab4-devsecops92.png[300,700]
+
.. この改善案で効果的に Image を更新していきます。
. Tekton タスク `s2i-java-11` を更新するのではなく、タスクを置き換えます。
.. OpenShift Administrator UIから、ocp-workshopプロジェクトが選択されていることを確認してから、Pipelines > Tasksに移動し、s2i-java-11タスクを削除してください。
+
image:images/lab4-devsecops93.png[300,700]
+
.. または、Tekton cli で
+
|===
|tkn task delete s2i-java-11
|===
+
. コマンドターミナルから新しい更新タスクを適用します:
+
|===
|kubectl apply -f https://raw.githubusercontent.com/RedHatDemos/SecurityDemos/master/2021Labs/OpenShiftSecurity/documentation/labs-artifacts/s2ijava-mgr.yaml --namespace=ocp-workshop
|または
|oc apply -f https://raw.githubusercontent.com/RedHatDemos/SecurityDemos/master/2021Labs/OpenShiftSecurity/documentation/labs-artifacts/s2ijava-mgr.yaml  -n ocp-workshop
|===
+
. パイプラインを再実行すると、デプロイメントが成功しました。developersの皆さん、おめでとうございます!
. パイプラインの実行結果は以下のようになります。
+
image:images/lab4-bonus-result.png[300,700]
+
[注意] https://raw.githubusercontent.com/RedHatDemos/SecurityDemos/master/2021Labs/OpenShiftSecurity/documentation/labs-artifacts/s2ijava-mgr.yaml[*labs-artifacts/s2ijava-mgr.yaml]*** **ファイルに、どのようにImageが修正されたかの詳細が記載されていますので、ご確認ください。ビルドタスクにステップを追加し、buildahを活用してイメージからパッケージマネージャーを削除しています(ファイル内で "rpm" or "yum" を検索してください)。
+
image:images/lab4-devsecops94.png[300,700]

=== Bonus exercise: CVEを一時的にスヌーズする

もし、Imageを修正したり、ビルドのポリシーに例外を追加する代わりに、特定のCVEsをスヌーズしたいだけなら。ACSでは、ユーザーが一定期間、CVEを一時的に無効にすることができます。

[注意] CVEs をスヌーズすると、すべてのポリシーで CVEs が一時的に無効になります。

このラボでは、イメージチェックに失敗する原因となる CVE をスヌーズして、パイプラインの構築を続行します。image-checkタスクがログから違反情報を報告していることがわかります。


image:images/lab4-devsecops95.png[300,700]

状況によっては、CVE を一定期間スヌーズさせたい場合があります。以下はその手順です:

.  `waffle icon` からACSコンソールに移動し、`Red Hat Advanced Clustered Security for Kubernetes` のリンクをクリックします。
左メニューのVulnerability Managementをクリックし、上部にあるCVEsボタンをクリックします。
. スヌーズするCVEを探し、必要な期間を選択してスヌーズを設定することができます。
+
image:images/lab4-devsecops96.png[300,700]


=== Bonus exercise: 通知

ACSは、管理するクラスタで特定のイベントが発生した場合にアラートを出すために、いくつかのNotifiersと統合することができます。私たちの場合は、より有用な情報を得るために、Slackと統合し、いくつかのPoliciesが違反されたときに通知を受け取れるようにしています:

image:images/lab4-devsecops97.png[300,500]

これらのポリシー通知は、システムで有効になっているシステムポリシーごとに有効にすることができるので、システムで適切な情報だけを受け取るために、独自の通知ベースラインを作成することができます。 +
以下、Stackroxの公式ドキュメント https://help.stackrox.com/docs/integrate-with-other-tools/integrate-with-slack/[Integrate with Slack] を元に、ACSとslackの連携を設定する手順を紹介します。

. Slack App を作成し、Incoming Webhooks を有効にして、手順 https://docs.openshift.com/acs/3.69/integration/integrate-with-slack.html#configure-slack_integrate-with-slack[here] を使って Webhook URL を取得します。
+
image:images/lab4-slack.png[300,500]
+
. `Platform Configuration` -> `Integration` を選択します。
+
image:images/lab4-devsecops98.png[100,300]
+
. `Slack` をクリックし、`New integration` をクリックします。
. 以下のフォームにSlack Appの情報を入力してください。
+
image:images/lab4-slack-int.png[100,300]
+
. システムポリシー上で Notification を有効にします: `Platform Configuration` -> `Policies` を選択します。
. -> Policy を選択 -> `Actions` -> `Edit policy` をクリックします。
+
image:images/lab4-devsecops99.png[300,700]

=== トラブルシューティング

==== コード分析の失敗

- 課題:
mvn が maven install 'sonar:sonar' を実行しているときに、Code Analysis がエラーを出すことがあります:

[source]
----
[[1;31mERROR[m] Failed to execute goal+
[32morg.apache.maven.plugins:maven-compiler-plugin:3.8.1:testCompile[m [1m(default-testCompile)[m on
project [36mspring-petclinic[m: [1;31mCompilation failure[m
[[1;31mERROR[m]
[1;31m/workspace/source/spring-petclinic/src/test/java/org/springframework/samples/petclinic/service/ClinicServiceTests.java:[30,51]
cannot access org.springframework.samples.petclinic.owner.Pet[m
[[1;31mERROR[m] [1;31m  bad class file:
/workspace/source/spring-petclinic/target/classes/org/springframework/samples/petclinic/owner/Pet.class[m
[[1;31mERROR[m] [1;31m    class file contains wrong class:
org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest[m
[[1;31mERROR[m] [1;31m    Please remove or make sure it appears in the correct subdirectory of the
classpath.[m
[[1;31mERROR[m] [1;31m[m
[[1;31mERROR[m] -> [1m[Help 1][m
[[1;31mERROR[m]
----

- 解決方法:
パイプラインを再実行すれば、追加で何かを変更することなく成功します。その後、結果は成功します:
[source]
----
[[1;34mINFO[m] Analyzed bundle 'petclinic' with 20 classes+
[[1;34mINFO[m] Analyzed bundle 'petclinic' with 20 classes
[[1;34mINFO[m]
[[1;34mINFO[m] [1m--- [0;32mmaven-jar-plugin:3.1.2:jar[m [1m(default-jar)[m @
[36mspring-petclinic[0;1m ---[m
[[1;34mINFO[m]
[[1;34mINFO[m] [1m--- [0;32mspring-boot-maven-plugin:2.2.5.RELEASE:repackage[m [1m(repackage)[m @
[36mspring-petclinic[0;1m ---[m
[[1;34mINFO[m] Replacing main artifact with repackaged archive
[[1;34mINFO[m] [1m------------------------------------------------------------------------[m
[[1;34mINFO[m] [1;32mBUILD SUCCESS[m
[[1;34mINFO[m] [1m------------------------------------------------------------------------[m
[[1;34mINFO[m] Total time: 01:55 min
[[1;34mINFO[m] Finished at: 2021-07-23T07:37:09Z
[[1;34mINFO[m] Final Memory: 118M/1245M
[[1;34mINFO[m] [1m------------------------------------------------------------------------[m
----

==== JUnit テストの失敗

コード解析を参照。再実行するだけです。エラーが修正されます。

====  アップロードサーバーへのzapプロキシレポートのアップロードに失敗しました。


zap proxy タスクが実行された後、間違ったフォルダ構造のためにレポートリポサーバへのアップロードに失敗する:
[source]
----
+ ls -lhrt /zap/wrk
total 76K

-rw-r--r--. 1 zap zap 75K Aug 20 10:41 petclinic-build-devm9hqv.html
+ echo 'Uploading the report into the report server'
Uploading the report into the report server

+ curl -u reports:reports -F path=petclinic-build-devm9hqv.html -F file=/zap/wrk/petclinic-build-devm9hqv.html -X POST http://reports-repo:8080/upload
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed

  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
100   335  100    36  100   299   7200  59800 --:--:-- --:--:-- --:--:-- 67000
{"message":"Internal Server Error"}
----

zap-proxyタスクを修正し、99行目を以下の curl の内容に置き換えることで、正しくアップロードできるようになります。
[source]
----
curl -u $(params.REPORTS_REPO_USERNAME):$(params.REPORTS_REPO_PASSWORD) -F path=$PIPELINERUN_NAME/$PIPELINERUN_NAME.html -F file=@/zap/wrk/$PIPELINERUN_NAME.html -X POST $(params.REPORTS_REPO_HOST)/upload; echo ""
----

その後、パイプラインを再実行し、効果的にzapプロキシレポートがレポートサーバーにアップロードされることを確認します:
[source]
----
+ curl -u reports:reports -F path=petclinic-build-dev-6f4569/petclinic-build-dev-6f4569.html -F file=@/zap/wrk/petclinic-build-dev-6f4569.html -X POST http://reports-repo:8080/upload
% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed

0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0
100 76435 100 89 100 76346 22250 18.2M --:File has been uploaded to petclinic-build-dev-6f4569/petclinic-build-dev-6f4569.html 🚀--:-- --:--:-- --:--:-- 18.2M
+ echo ''
----

image:images/lab4-devsecops100.png[300,700]
